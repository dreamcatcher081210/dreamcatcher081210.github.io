---
layout:     post
title:      Java volatile 关键字解读
subtitle:   volatile
date:       2019-11-08
author:     BY
header-img: img/post-bg-rwd.jpg
catalog: true
tags:
    - volatile
    - Java
---
### 一、开篇
在上一篇文章《Java 锁》里，我们着重介绍了解决多线程在访问同一共享资源时，并发操作产生的数据不安全的方案——锁。

在对共享资源进行操作时，只允许一个持有锁的线程进行操作，其余线程等待获取锁，读写锁可以做到多个读线程进行读操作，但是写操作依然是互斥的。

那可以不可以，写操作互斥加锁，读操作不加锁，可以啊，当然可以了。先说说并发环境下的三个重要特性，原子性，可见性，有序性，只有满足了这三个特性，才能确保并发操作的正确性。

##### 1）原子性，一个或多个操作要么全部执行且执行过程不被中断，要么全部不执行（防止复合操作，即一段代码一个线程执行时可以确保原子性，但是多个线程共同执行时，就不能确保原子性了）。

##### 2）可见性，多个线程访问同一共享资源，其中一个线程进行了修改，修改后的值能立即被其它线程获取（修改后的值立即更新到主存中，当其他线程读取时，会到主存中读取）。

##### 3）有序性，程序执行的顺序按照代码的先后顺序执行，因为编译器会进行编译优化，当多线程运行时，会引起很多问题，synchronized、Lock也可以解决有序性问题。

话归原题，只要保证写操作满足原子性，读操作满足可见性和有序性就ok了！明白了吗？

volatile：说了半天不就是我吗？

### 二、定论
当类的成员变量和静态成员变量被volatile修饰，就代表了：

##### 1）禁止指令重排。
##### 2）变量的最新值会被立即更新到主存中，其它线程可以获取最新的修改值。

处理器为了提高处理速度，不会直接读和内存进行通讯，而是将主内存数据读取到处理器内部缓存后，进行操作，但是操作完数据以后，不知道什么时候写入内存。

如果对声明了volatile变量进行写操作，JVM会向处理器发送一条Lock前缀指令，会将变量所在缓存行的数据写回到主内存，这一步能够确保当线程对该变量进行写操作后，会立即更新到主内存中。

这个时候其它处理器的缓存还是旧值，所以在多处理器环境下，为了确保各处理器缓存一致，每个处理器会嗅探在总线上传播的数据来检查自己的缓存是否有效，当处理器发现自己的缓存行对应的内存地址与总线上传播的对应数据内存地址不一样，就会将当前处理器的缓存行设置成无效状态，当这个处理器对此数据进行修改操作时（一定包含读操作），会强制从主存中把最新的数据读取到处理器缓存中。这一步确保了其它线程获取声明了volatile的变量都是主存中的最新值。

![volatile流程图.png](https://upload-images.jianshu.io/upload_images/7190871-1850a6c99552fb71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

上面的流程图展示了volatile的原理，以及volatile无法满足原子性的原因。

### 三、应用

上一篇提到的AQS，内部维护的state变量就是被volatile所修饰的，在ReentrantLock可重入锁里，state代表的就是持有锁的次数，state为0代表没有线程获取锁。

### 四、结束
volatile无法保证原子性，但是可以保证可见性和有序性。



