---
layout:     post
title:      Java 锁
subtitle:   锁
date:       2019-10-28
author:     BY
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - 锁
    - Java
---
### 一、锁分类
Java中有两种加锁的方式：一种是用synchronized关键字，另一种是用Lock接口的实现类。

### 二、synchronized与Lock接口实现类的区别：
1）synchronized 是java关键字，是虚拟机层面的，当代码块执行完毕或发生异常时，虚拟机会自动释放锁。
2）Lock实现类 是代码层面的，需要我们在代码执行完毕或发生异常时，手动释放锁。
3）Lock更灵活，更能定制用户需求，比如可中断性，在使用synchronized锁的前提下，一个线程持有锁，在代码块执行期间，其它线程也要执行此代码块，但是锁被另一个线程率先持有了，那么这些线程只能等待，如果想让线程等待一定时间，或者直接中断，synchronized是无法做到，
而Lock可以帮助我们实现自定义的一些需求，诸如上面提到的能够知道锁已被其它线程持有、读写锁。就好比一个是成品，一个是半成品。成品拿来直接吃，半成品可以加一些自己喜欢的佐料，然后再吃。
4）在使用Lock锁时，如果忘记关闭锁，那么会导致死锁的情况发生。而synchronized不会发生，除非代码块进入死循环一直无法释放持有的锁。

### 三、性能
在锁竞争不是很激烈的场景下，二者差距不大。而当锁竞争激烈的时候，Lock的性能远超于synchronized，根据不同场景，自行选定。

此次要展开讲的是Lock相关实现类。

### 四、锁的分类

#### 1）公平锁、非公平锁 - 获取锁的公平性
公平锁是指按照线程申请持有锁的顺序进行锁的颁发，类似队列的概念，先到先得，后到后得。
非公平锁，是指随机分配锁，无规律可循，synchronized是非公平锁。

#### 2）可重入锁、不可重入锁
可重入锁，是指持有锁的线程，再次进入相同锁锁定的方法时，自动获取锁无需等待。ReentrantLock也是可重入锁。
不可重入锁，无法区分敌我，一概等待，容易造成死锁。

#### 3）互斥锁/读写锁 - 纯功能性划分
互斥锁（排他锁）：锁只能颁发给一个线程持有，ReentrantLock是独享锁。
读写锁：在读-读的情况下，读锁可以颁发给多个线程进行读操作，但是写锁是互斥锁，写-写、读-写的过程是互斥的，ReadWriteLock是读写锁。

#### 4）悲观锁、乐观锁 - 心态
悲观锁、乐观锁应该是一种锁的理念，而不是具体实现，各编程语言乃至数据库都有相关实现。
悲观锁，悲观的认为，对同一数据的并发操作都是要进行修改的，我们可以理解为小心谨慎。
乐观锁，乐观的认为，对同一数据的并发操作不一定要进行修改，只是在进行修改的时候进行数据检测（CAS操作，compareAndSwap），是否发生修改，没有发生修改，正常执行，如发现已修改，返回给用户，让用户抉择下一步该如何行事，我们可以理解为，心大格局大，不怕背锅。

#### 5）自旋锁 - 获取不到锁时的处理方式
线程A持有锁进行逻辑处理，此时线程B过来，想要获取锁，但是发现锁被其它线程持有了，通常情况下，线程B进入休眠，等待锁的释放，而自旋锁不会立即挂起，自旋锁会执行一个空循环，当持有锁的线程触发了释放锁的条件，自旋锁会得到通知，跳出循环体，尝试获取锁。
这样做的好处就是减少了线程上下文切换带来的消耗。缺点也很明显，占用cpu，尤其是锁竞争激烈的时候。
自Java7之后，自旋锁总是会被执行，自旋次数由jvm自动调整。

### 五、Lock接口的实现类
#### 1）ReentrantLock可重入锁
可重入锁的原理是在锁内部维护了一个线程标识，标识该锁目前被那个线程占用，然后关联一个计数器，该锁没有被任何线程占用时计数器为0，当一个线程持有了该锁，计数器+1，其他线程在获取该锁时候发现锁的所有者不是自己所以被阻塞，
但是当获取该锁的线程再次获取锁时候发现锁拥有者是自己会把计数器值+1， 当释放锁后计数器会-1，当计数器为0时候，锁里面的线程标识重置为null，
这时候阻塞的线程会获取被唤醒来获取该锁。ReentrantLock 拥有与synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。
此外，它还提供了在激烈争用情况下更佳的性能。（换句话说，当许多线程都想访问共享资源时，JVM 可以花更少的时候来调度线程，把更多时间用在执行线程上。）

#### 2）ReentrantReadWriteLock读写锁
正常情况下对同一数据的并发并不都是修改操作，存在读操作和写操作，基于这个前提ReentrantReadWriteLock能提供比排他锁更好的性能优势和吞吐。
读写锁内部维护了两个静态内部类ReadLock和WriteLock，一个读锁，一个写锁。
ReentrantReadWriteLock支持以下功能：
①支持公平和非公平的获取锁的方式；
②支持可重入。读线程在获取了读锁后还可以获取读锁；写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；
③还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不允许的；
④读取锁和写入锁都支持锁获取期间的中断；
⑤Condition支持。仅写入锁提供了一个 Conditon 实现；读取锁不支持 Conditon ，readLock().newCondition() 会抛出 UnsupportedOperationException。 

#### 3）StampedLock读写锁
Java8中新增加的读写锁，是对ReentrantReadWriteLock读写锁的改机版。改进思想就是，读写之间不会阻塞对方，写写之间依然保持阻塞。



